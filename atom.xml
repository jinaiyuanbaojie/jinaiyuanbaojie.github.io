<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jinaiyuanbaojie.github.io/</id>
    <title>乱弹软件</title>
    <updated>2019-06-07T16:22:11.505Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jinaiyuanbaojie.github.io/"/>
    <link rel="self" href="https://jinaiyuanbaojie.github.io//atom.xml"/>
    <subtitle>小舟从此逝，江海寄余生！</subtitle>
    <logo>https://jinaiyuanbaojie.github.io//images/avatar.png</logo>
    <icon>https://jinaiyuanbaojie.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 乱弹软件</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript中的继承]]></title>
        <id>https://jinaiyuanbaojie.github.io//post/javascript-zhong-de-ji-cheng</id>
        <link href="https://jinaiyuanbaojie.github.io//post/javascript-zhong-de-ji-cheng">
        </link>
        <updated>2018-06-27T16:16:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开始之前">开始之前</h2>
<ul>
<li><code>JavaScript</code>使用场景
<ul>
<li>Web前端</li>
<li>服务器</li>
<li>PC跨平台应用</li>
<li>移动端：<code>React Native</code> <code>Weex</code> <code>微信小程序</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>Jeff Atwood: Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>
</blockquote>
<ul>
<li><code>JavaScript</code>的世界一切都是对象,函数也是对象!对象是<strong>一等公民</strong>！</li>
<li><code>JavaScript</code>是<strong>动态</strong>语言：可以方便的在运行时给对象添加或删除属性、方法</li>
</ul>
<blockquote>
<p>动态性比较：JavaScript &gt; Objective-C &gt; Java &gt; Swit &gt; C++</p>
</blockquote>
<ul>
<li>
<p><code>JavaScript</code><strong>多范式</strong>语言</p>
<ul>
<li>过程式</li>
<li>面向对象</li>
<li>函数式</li>
<li>响应式</li>
<li>....</li>
</ul>
</li>
<li>
<p><code>JavaScript</code>调试</p>
<ul>
<li>浏览器环境下运行：Chrome浏览器开发者工具</li>
<li>Node环境运行：https://nodejs.org/zh-cn/</li>
</ul>
</li>
<li>
<p><code>Hello world</code></p>
</li>
</ul>
<pre><code class="language-js">    var jsObject = {name:'Andrew'}
    
    console.log(jsObject) //{name: &quot;Andrew&quot;}
    console.log(jsObject.name) //Andrew
    console.log(typeof jsObject) //object
    console.log(jsObject.age) //undefined
    jsObject.age = 30
    console.log(jsObject.age) //30

    function foo(){
        return 'I am foo.'
    }
    
    jsObject.speak = foo
    jsObject.speak() //&quot;I am foo.&quot;
    delete jsObject.speak
    console.log(jsObject.speak) //undefined
    
    console.log(typeof foo) //function
    foo.customTag = 'HomeCredit';
    console.log(foo.customTag) //HomeCredit
    
    function foo2(){ 
        return 2018
    }
    foo.customFunc = foo2
    foo.customFunc() //2018
</code></pre>
<h2 id="继承">继承</h2>
<ul>
<li><code>JavaScript</code>基于原型继承的语言:
<ul>
<li><code>prototype</code>(<strong>原型</strong>):只有函数对象拥有此字段，创建一个函数就有一个对应的函数原型对象，<code>prototype</code>指向函数原型对象</li>
<li><code>__proto__</code>(<strong>原型链</strong>):任何对象都拥有<code>__proto__</code>这个字段，用来在运行时查找调用的<code>属性</code>、<code>方法</code>,<code>__proto__</code>也指向某个对象，以此构成查找链。</li>
<li>通过函数创建的对象的<code>__proto__</code>字段，自动指向函数的原型对象</li>
</ul>
<pre><code class="language-js">function Foo(){};
var foo = new Foo(); //只有函数才能使用new关键字
foo.__proto__ == Foo.prototype
</code></pre>
<blockquote>
<p>tips:<code>JavaScript</code>的世界一切都是对象</p>
</blockquote>
</li>
<li>代码</li>
</ul>
<pre><code class="language-js">function Base(){
    
}; //声明Base类，同时也是构造函数constructor，
console.log(Base) //ƒ Base(){}

console.log(Base.prototype)
/*
Base.prototype
    constructor:ƒ Base()
    __proto__:Object
*/
console.log(Base.__proto__) //ƒ () { [native code] }, Function.prototype
Base.__proto__ == Function.prototype //true

var base = new Base();
base.constructor //ƒ Base(){}
base.constructor == Base //true
base.__proto__ == Base.prototype //true

Object.prototype
/*
constructor:ƒ Object()
hasOwnProperty:ƒ hasOwnProperty()
isPrototypeOf:ƒ isPrototypeOf()
propertyIsEnumerable:ƒ propertyIsEnumerable()
toLocaleString:ƒ toLocaleString()
toString:ƒ toString()
valueOf:ƒ valueOf()
__defineGetter__:ƒ __defineGetter__()
__defineSetter__:ƒ __defineSetter__()
__lookupGetter__:ƒ __lookupGetter__()
__lookupSetter__:ƒ __lookupSetter__()
get __proto__:ƒ __proto__()
set __proto__:ƒ __proto__()
*/

Function.prototype // ƒ () { [native code] }
Object.__proto__ == Function.prototype //true
Function.prototype.__proto__ == Object.prototype //true
Base.__proto__ == Function.prototype //true

base.toString(); //&quot;[object Object]&quot; 

Base.prototype = {
    method1:function(){
        return &quot;Base method1&quot;;
    },
    
    method2:function(){
        return &quot;Base method2&quot;;
    }
};
base.method1(); //undefined
base.method2(); //undefined

var base_new = new Base();
base_new.method1(); //&quot;Base method1&quot;
base_new.method2(); //&quot;Base method2&quot;

function Derived(){}
Derived.prototype = {
    method1:function(){return &quot;Derived method1&quot;;},
    method3:function(){return &quot;Derived method3&quot;;}
}
Derived.prototype.__proto__ = Base.prototype;
var derived = new Derived();
derived.method1(); //&quot;Derived method1&quot;
derived.method2(); //&quot;Base method2&quot; 
derived.method3(); //&quot;Derived method3&quot;
</code></pre>
<ul>
<li>图例<br>
<img src="https://jinaiyuanbaojie.github.io//post-images/1559924380346.jpg" alt=""></li>
<li><code>ES6</code>
<ul>
<li>新一代的js版本</li>
<li>添加了各种语法和语法糖</li>
<li><a href="http://es6.ruanyifeng.com/#docs/class-extends">文档</a>：阮一峰教程</li>
<li><a href="https://babeljs.io/en/repl">Babel</a>: ES6代码转ES5</li>
</ul>
</li>
</ul>
<pre><code class="language-js">class Base {
  foo(){
    return &quot;i am base&quot;
  }
}

class Derived extends Base {
  foo(){
    return &quot;i am Derived&quot;
  }
}
</code></pre>
<p>转码后</p>
<pre><code class="language-js">&quot;use strict&quot;;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(&quot;this hasn't been initialised - super() hasn't been called&quot;); } return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) { throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

var Base = function () {
  function Base() {
    _classCallCheck(this, Base);
  }

  _createClass(Base, [{
    key: &quot;foo&quot;,
    value: function foo() {
      return &quot;i am base&quot;;
    }
  }]);

  return Base;
}();

var Derived = function (_Base) {
  _inherits(Derived, _Base);

  function Derived() {
    _classCallCheck(this, Derived);

    return _possibleConstructorReturn(this, (Derived.__proto__ || Object.getPrototypeOf(Derived)).apply(this, arguments));
  }

  _createClass(Derived, [{
    key: &quot;foo&quot;,
    value: function foo() {
      return &quot;i am Derived&quot;;
    }
  }]);

  return Derived;
}(Base);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XCConfig]]></title>
        <id>https://jinaiyuanbaojie.github.io//post/xcconfig</id>
        <link href="https://jinaiyuanbaojie.github.io//post/xcconfig">
        </link>
        <updated>2018-05-16T16:13:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="xcconfig">XCConfig</h1>
<p><code>xcconfig</code>文件是Xcode的工程构建配置文件，相当于把Project-&gt;Build Settings中的各种选项<strong>文本化</strong>。<br>
你可以选中Build Settings中任何配置项，<code>cmd+c</code>，然后在<code>xcconfig</code>文件中<code>cmd+v</code>后就可以看到效果。</p>
<h2 id="objective-c时代">Objective-C时代</h2>
<p>因为Objective-C兼容C，所以也理所应当支持宏。<br>
在xcconfig文件中预定义一些宏，可以让代码中少很多<code>if{...}else{...}</code>的语句。类似于开关。</p>
<h2 id="swift时代">Swift时代</h2>
<p>Swift本身不再支持宏，所以OC时代的便利性下降。当然不支持宏是正确的。可是如何在Swift中享受OC时代的便利呢？</p>
<ol>
<li>桥接OC</li>
<li>只能设置Swift支持的Flag （<strong>Other Swift Flags</strong>）</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blog]]></title>
        <id>https://jinaiyuanbaojie.github.io//post/blog</id>
        <link href="https://jinaiyuanbaojie.github.io//post/blog">
        </link>
        <updated>2018-01-12T16:08:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="blog">Blog</h1>
<p>记录些有趣的小问题
工作和生活中的小事，在GitHub上吐吐槽。茫茫页面，你找不到我的！</p>
<h2 id="一首喜欢的小词">一首喜欢的小词</h2>
<p><strong>临江仙 夜饮东坡醒复醉</strong> 苏轼 宋</p>
<p>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。</p>
<p>长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。</p>
<h2 id="一首喜欢的古诗">一首喜欢的古诗</h2>
<p><strong>问刘十九</strong> 白居易 唐</p>
<p>绿蚁新醅酒，红泥小火炉。</p>
<p>晚来天欲雪，能饮一杯无。</p>
]]></content>
    </entry>
</feed>